.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Morpheus 3"
.TH Morpheus 3 "2011-03-15" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Morpheus \- the ultimate configuration engine
.SH "VERSION"
.IX Header "VERSION"
version 0.39
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Morpheus "/foo/bar" => [
\&      qw($V1 $V2 $V3),
\&      "v5" => \(aq$V5\(aq, "v6/a" => \(aq$A\(aq,
\&      "v7" => [ \(aq$C\(aq, \(aq$D\(aq, "e" => \(aq$E\(aq ],
\&  ];
.Ve
.PP
.Vb 3
\&  use Morpheus \-defaults => {
\&      "/foo/bar" => { x => 1, y => 2},
\&  };
.Ve
.PP
.Vb 3
\&  use Morpheus \-overrides => {
\&      "/foo/bar" => { "x/y" => 3 },
\&  };
.Ve
.PP
.Vb 3
\&  use Morpheus \-export => [
\&      qw( morph merge normalize )
\&  ];
.Ve
.PP
.Vb 1
\&  use Morpheus; # only \(aqmorph\(aq function is exported by default
.Ve
.PP
.Vb 1
\&  $bar = morph("/foo/bar");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Morpheus is a configuration engine that completely separates config consumers from config providers.
.PP
Consumers can obtain configuration values by using this module or morph script.
Configuration values are binded to various nodes in the global config tree, similar to virtual file system. Consumers can ask for any node or for any subtree.
.PP
Providers are plugins which can populate configuration tree from any sources: local configuration files, configuration database, environment, etc.
The overall program configuration is merged together from all data provided by plugins.
.SH "CONFIGURATION TREE"
.IX Header "CONFIGURATION TREE"
Every config value is binded to a key inside the global configuration tree. Keys use \f(CW\*(C`/\*(C'\fR as a separator of their parts, similar to usual filesystem conventions.
.PP
Any value which is a hashref will become the subtree in the configuration tree and will be merged with other values if possible. For example, if one plugin provides \f(CW\*(C`{ foo => 5 }\*(C'\fR for \f(CW\*(C`/blah\*(C'\fR key, and another plugin provides \f(CW\*(C`{ bar => 6 }\*(C'\fR for \f(CW\*(C`/blah\*(C'\fR key, then \f(CW\*(C`morph("/blah")\*(C'\fR will return \f(CW\*(C`{ foo => 5, bar => 6 }\*(C'\fR.
.PP
Leading \f(CW\*(C`/\*(C'\fR in key name is optional, and \f(CW\*(C`morph("/foo")\*(C'\fR and \f(CW\*(C`morph("foo")\*(C'\fR are the same by now, but in the future some analog of \f(CW\*(C`chdir\*(C'\fR may be implemented. So leading \f(CW\*(C`/\*(C'\fR is probably more compatible with future releases.
.SH "IMPORT SYNTAX"
.IX Header "IMPORT SYNTAX"
There are a lot of things which you can pass to \f(CW\*(C`use Morpheus\*(C'\fR:
.Sh "Import to global variables"
.IX Subsection "Import to global variables"
This code will set your package's \f(CW$X\fR variable to the value binded to \f(CW\*(C`/foo/bar/X\*(C'\fR key:
.PP
.Vb 3
\&  use Morpheus "/foo/bar" => [
\&    \(aq$X\(aq
\&  ];
.Ve
.PP
You can pass several variables in the list:
.PP
.Vb 3
\&  use Morpheus "/foo/bar" => [
\&    qw( $X $Y $Z )
\&  ];
.Ve
.PP
Import value to variable with the name different from key's last part:
.PP
.Vb 3
\&  use Morpheus "/foo/bar" => [
\&    "X" => \(aq$FOO_BAR_X\(aq,
\&  ];
.Ve
.PP
Or go to the next level in configuration tree:
.PP
.Vb 4
\&  use Morpheus "/foo" => [
\&    blah => \(aq$FOO_BLAH\(aq,
\&    bar => [ "X" => \(aq$FOO_BAR_X\(aq ],
\&  ];
.Ve
.Sh "Set defaults and override already defined values"
.IX Subsection "Set defaults and override already defined values"
This code will set default values for \f(CW\*(C`/foo/bar/x\*(C'\fR and \f(CW\*(C`/foo/bar/y\*(C'\fR:
.PP
.Vb 3
\&  use Morpheus \-defaults => {
\&    "/foo/bar" => { x => 1, y => 2 },
\&  };
.Ve
.PP
Since hashrefs and tree nodes are always equivalent in Morpheus, these following versions of code do the same thing too:
.PP
.Vb 3
\&  use Morpheus \-defaults => {
\&    "/foo" => { bar => { x => 1, y => 2 } },
\&  };
.Ve
.PP
Or:
.PP
.Vb 4
\&  use Morpheus \-defaults => {
\&    "/foo/bar/x" => 1,
\&    "/foo/bar/y" => 2,
\&  };
.Ve
.PP
Values which are set in this fashion are only defaults and will be \fBoverriden\fR if any other plugins provide them too.
.PP
If you'll say \f(CW\*(C`\-overrides\*(C'\fR instead of \f(CW\*(C`\-defaults\*(C'\fR, on the contrary, your values will \fBoverride\fR any values provided by plugins.
.Sh "Import helper functions"
.IX Subsection "Import helper functions"
This module provides several helper functions. They can be imported into your code like this:
.PP
.Vb 3
\&  use Morpheus \-export => [
\&      qw( morph merge normalize )
\&  ];
.Ve
.PP
If this \f(CW\*(C`\-export\*(C'\fR option is not specified, then only \f(CW\*(C`morph()\*(C'\fR function will be imported.
.PP
More about these functions below
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
These functions can be imported via \f(CW\*(C`\-export\*(C'\fR option.
.IP "\fBmorph($key)\fR" 4
.IX Item "morph($key)"
Get value by given key. This function is imported by default.
.IP "\fBnormalize($data)\fR" 4
.IX Item "normalize($data)"
Expand data by replacing all keys containing \f(CW\*(C`/\*(C'\fR in their names with nested hashrefs.
.Sp
For example, \f(CW\*(C`normalize({ "a/b/c" => "d" })\*(C'\fR will return \f(CW\*(C`{ a => { b => { c => "d" } } }\*(C'\fR.
.ie n .IP "\fBmerge($value, \fB$patch\fB)\fR" 4
.el .IP "\fBmerge($value, \f(CB$patch\fB)\fR" 4
.IX Item "merge($value, $patch)"
Merge two configuration subtrees together, including all deeply nested substructures.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrei Mishchenko <druxa@yandex\-team.ru>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Yandex \s-1LLC\s0.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

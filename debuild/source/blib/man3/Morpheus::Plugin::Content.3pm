.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Morpheus::Plugin::Content 3"
.TH Morpheus::Plugin::Content 3 "2011-03-15" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Morpheus::Plugin::Content \- base class for plugins that evaluate user defined perl configs
.SH "VERSION"
.IX Header "VERSION"
version 0.39
.SH "CONFIGURATION BLOCKS"
.IX Header "CONFIGURATION BLOCKS"
Some morpheus plugins, such as Morpheus::Plugin::File, Morpheus::Plugin::DB and Morpheus::Plugin::Env, provide configuration data by evaluating a custom user defined pieces of a perl code. These code fragments are refered as \fIConfiguration blocks\fR. There are two styles of those blocks.
.Sh "Imperative style"
.IX Subsection "Imperative style"
Example:
.PP
.Vb 4
\&    $FOO = "foo";
\&    $BAR = 42;
\&    my $x = 1;
\&    $BAZ = { x => $x };
.Ve
.PP
The blocks of this style are interpreted as follows. The code is evaluated inside of an autogenerated sandbox package, then the values stored in the stash (a hash of global variables) of this package are gathered into a hash and it is considered a return value of a block, \*(L"my\*(R" variables are ignored. So the example above provides the following configuration:
.PP
.Vb 7
\&    {
\&        \(aqBAZ\(aq => {
\&            \(aqx\(aq => 1
\&        },
\&        \(aqBAR\(aq => 42,
\&        \(aqFOO\(aq => \(aqfoo\(aq
\&    }
.Ve
.PP
Arrays (@) and hashes (%) are also currently supported and result in globrefs as configuration values. For example a block like
.PP
.Vb 3
\&    $X = "x";
\&    @X = (1,2,3);
\&    %Y = ( a => "b" );
.Ve
.PP
will lead to a configuration
.PP
.Vb 4
\&    {
\&        \(aqX\(aq => \e*GLOB1 # ${...} of this glob is "x" while @{...} of it is (1,2,3)
\&        \(aqY\(aq => \e*GLOB2 # %{...} of this glob is (a => "b")
\&    }
.Ve
.PP
Arrays (@) and hashes (%) are wrapped into globrefs even when they do not collide with a scalar ($) value. It is done to distinguish between
.PP
.Vb 1
\&    $X = [1,2,3];
.Ve
.PP
and
.PP
.Vb 1
\&    @X = (1,2,3);
.Ve
.PP
In fact this feature about globrefs is believed to be deprecated and may be removed in the future. Try to use only scalars ($) while providing your configuration values and wrap the arrays and hashes you require into arrayrefs and hashrefs.
.PP
In case after the evaluation of a block the stash is empty or contains only subs, the block is considered to be of a second, functional style.
.Sh "Functional style"
.IX Subsection "Functional style"
Example:
.PP
.Vb 6
\&    my $x = 1;
\&    {
\&        FOO => "foo",
\&        BAR => 42,
\&        BAZ => { x => $x },
\&    }
.Ve
.PP
The blocks of this style are interpreted differently. The result of evaluation (the last statement or an argument of a \*(L"return\*(R" operator) is the result of a functional style block while the stash (containing nothing except subs) is ignored.
.Sh "Comparison"
.IX Subsection "Comparison"
The configuration values may be subs themselves. It doesn't affect the style of a block, for example
.PP
.Vb 1
\&    $FOO = sub { print "foo" };
.Ve
.PP
is still an imperative style block, not a functional style one. From the point of view of a stash \f(CW$FOO\fR is a scalar regardless its value is a sub(ref). But
.PP
.Vb 6
\&    sub FOO {
\&        return shift . "oo";
\&    }
\&    {
\&        BAR => FOO("f"),
\&    }
.Ve
.PP
is a functional style block, as the only thing stash contains after the block evaluation is \f(CW&FOO\fR which is a sub.
.PP
Imperative and functional styles both have their advantages and disadvantages, so you may pick the style that better fits your current needs. Functional style block may provide a primitive value like just a string or number, that cannot be expressed as an imperative style block. You cannot defined a variable with an empty name, so imperative blocks always return a hashref as their result. Also in functional style blocks long keys expansion is supported, that is
.PP
.Vb 4
\&    {
\&        "x/y/z" => 1,
\&        ...
\&    }
.Ve
.PP
becomes
.PP
.Vb 4
\&    {
\&        x => { y => { z => 1 } },
\&        ...
\&    }
.Ve
.PP
that makes functional blocks very suitable to provide sevaral simple but deeply nested values.
.Sh "\s-1ADVANCED\s0 \s-1TECHNIQUES\s0"
.IX Subsection "ADVANCED TECHNIQUES"
You are free to use any kind of perl operators in configuration blocks. Any strings and numbers operations, branches, cycles, function definitions and calls, even imports of arbitrary perl modules. If your configuration block is a large and complex one, you may consider using strict and warnings. One of the most mysterious things your are allowed to do is the resursive calls back to the Morpheus to get some configuration variables, while your block is providing some configuration variables itself. Though there exists some protection from infinite recursion, use this feature at your own risk, it is your own responsibility to prevent cyclic dependencies between the configuration variables. No warranty etc. :)
.PP
There are several typical applications of the recursive Morpheus calls. Do not forget to \f(CW\*(C`use Morpheus\*(C'\fR in a configuration block to make recursive calls possible.
.Sh "Links and dependencies"
.IX Subsection "Links and dependencies"
Links are like symlinks in a file system. You may configure some variable to get its value from some other variable:
.PP
.Vb 2
\&    use Morpheus;
\&    $VAR2 = morph("/FOO/BAR/VAR1");
.Ve
.PP
It is especially useful when you are refactoring your configuration tree structure but still want your legacy programs to work properly.
.PP
Not only equality but more complex dependencies between variables may also be expressed, for example:
.PP
.Vb 4
\&    use Morpheus;
\&    $LOG_NAME = morph("/LOG_DIR") . "/my.log";
\&    $LIST2 = [ @{morph("/LIST1")}, "some", "more", "items" ];
\&    $LIST3 = [ grep { $_ !~ /some|filter/ } @{"/LIST1"} ];
.Ve
.Sh "High level configuration"
.IX Subsection "High level configuration"
Technically this is a particular case of configuration variables dependency, but ideologically it is a bit different thing. You may define some high level configuration variables like debug/release or dev/testing/production and make other configuration variables depend on them. The choice of those high level configuration values would also be made by Morpheus at some other point of configuration.
.PP
.Vb 6
\&    use Morpheus;
\&    my $debug = morph("/debug");
\&    $THREADS = 50;
\&    $THREADS = 1 if $debug; # fewer theads when running in debug mode
\&    $LOG_LEVEL = "INFO";
\&    $LOG_LEVEL = "DEBUG" if $debug; # more verbose logging in debug mode
.Ve
.PP
.Vb 6
\&    $SOME_SERVICE_URL = {
\&        dev => "http://some\-service\-dev:12345/",
\&        testing => "http://some\-service\-dev/",
\&        production => "http://some\-service/",
\&        # pick up a proper some\-service url depending on the /environment value
\&    }\->{morph("/environment")} or die "unexpected /environment";
.Ve
.Sh "Super calls"
.IX Subsection "Super calls"
Morpheus plugins are arranged with respect to their priority. Sometimes there exists the same mechanism within a single plugin too, for example a configuration file example.20.cfg has a priority over example.10.cfg, though they are both interpreted by the same \f(CW\*(C`Morpheus::Plugin::File\*(C'\fR. A higher priority config overrides the value provided by a lower proirity one. There are cases when a higher priority config wants to adjust the lower priority value rather then simply replace it. In \s-1OOP\s0 it is achieved using the \*(L"super\*(R" call (\*(L"super\*(R" keyword in java for example). Morpheus provides the similar opportunity: just access the same configuration variable you are now trying to provide and you will make a super call. Do not worry about the infinite recursion, Morpheus engine keeps track of the plugins and even particular configuration blocks that are currently being evaluated so it skips them upon a recursive call.
.PP
Consider an example:
.PP
.Vb 3
\&    # example.10.cfg:
\&    $X = 1;
\&    $Y = 2;
.Ve
.PP
.Vb 3
\&    # example.20.cfg:
\&    use Morpheus;
\&    $X = morph("/example/X") + 3;
.Ve
.PP
This leads to the configuration of \*(L"/example/\*(R"
.PP
.Vb 4
\&    {
\&      \(aqX\(aq => 4,
\&      \(aqY\(aq => 2
\&    }
.Ve
.PP
as the higher priority config example.20.cfg has accessed a value of X provided by the lower proirity config example.10.cfg.
.Sh "Partial block evaluation support"
.IX Subsection "Partial block evaluation support"
Morpheus supports a partial evaluation of the imperative style configuration blocks. That is already defined stash variables are visible through resursive calls though configuration block may be not fully evaluated yet.
.PP
.Vb 4
\&    # example.cfg:
\&    use Morpheus;
\&    $X = 1;
\&    $Y = morph("/example/X") + 2;
.Ve
.PP
results in configuration
.PP
.Vb 4
\&    {
\&        \(aqX\(aq => 1,
\&        \(aqY\(aq => 3
\&    }
.Ve
.PP
Please pay attention that a simplier config
.PP
.Vb 2
\&    $X = 1;
\&    $Y = $X + 2;
.Ve
.PP
is not the same as in the example above, because the value of /example/X may be overriden by a higher priority config. This simplyfied version will not be affected, but the original config will modify the value of /example/Y accordingly.
.PP
Functional style blocks do not support partial evaluation feature. Config
.PP
.Vb 6
\&    # example.cfg:
\&    use Morpheus;
\&    {
\&        X => 1,
\&        Y => morph("/example/X") + 2,
\&    }
.Ve
.PP
will (wrongly) return a configuration
.PP
.Vb 4
\&    {
\&        \(aqX\(aq => 1,
\&        \(aqY\(aq => 2
\&    }
.Ve
.PP
as morph(\*(L"/example/X\*(R") will return undef at the moment it is called.
.Sh "Caution"
.IX Subsection "Caution"
Though the recursive calls to Morpheus from the configuration blocks (that are evaluated by Morpheus plugins) is allowed, we highly recommend not to make calls to Morpheus within the code of Morpheus plugins initialization. Neither directly nor indirectly by using modules that are using Morpheus. When Morpheus starts compiling its plugins and it brings perl interpreter back to compiling Morpheus and calling its methods, it leads to a complete mess. Calling Morpheus from the configuration blocks is a big difference, all the plugins are fully initialized at that moment.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrei Mishchenko <druxa@yandex\-team.ru>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Yandex \s-1LLC\s0.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
